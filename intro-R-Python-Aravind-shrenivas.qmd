---
title: "INFO 523 Exercise"
subtitle: "HW1: Introduction to R Exercise"
format: 
  pdf:
    toc: true
    number-sections: false
    colorlinks: true

editor: visual
---

# Part 1

## Basics of R

### Finding the R version

```{r}
R.version
```

The code `R.version()`{style="color: #252525;"} gives us the details of the platform, the kind of system on which our system operates (e.g., here it is a 64-bit operating system), the OS, the date, the version of R installed (4.3.1), and other general information about the environment where R has been installed.

### Packages

Packages are important components of any programming language because they are like supporting pillars which makes our code run. There are several packages in R which will be used for various purposes.

Let's install the package `DMwR2` . The syntax for this is `install.packages("DMwR2")` .

```{r, eval=FALSE}
install.packages("DMwR2")
```

This is one of the main package which we are going to use in Data mining subject. We shall see some of it's other functionalities below.

If we run into any kind of trouble with respect to any package we installed, we can use the code `help()` to see what is really in the document. Now, let's test it out by running the code `help(package="DMwR2")` .

```{r}
help(package="DMwR2")
```

![fig 1. help() Output](output-help().png)

When I executed the `help(package="DMwR2")` command, the help menu which was on the side opened up which contains the compelte documentation for the package 'DMwR2'.

After installing of package, I need to use it. So, there are two ways by which I can access the package which I will list below.

1.  There is a keyword called `library()` . When I want to use a function repeatedly, I can just load up the function to the temporary memory using this function for frequent use. For eg. let's say I want to use this 'DMwR2' package, the following code must be used.

    ```{r}
    library(DMwR2)
    ```

    Now, I can access any function or dataset associated with the package 'DMwR2' by using it's name directly. An example is given below.

    ```{r}
    # I will load an available dataset 'algae' directly by referencing it's name
    data(algae)
    algae
    ```

    If I want to find the row number of entries which contains many NA data, I will use `manyNAs(algae)` .

    ```{r}
    manyNAs(algae)
    ```

    From the above, we can infer that columns 62 and 199 contains many inaccurate data.

2.  If I want to use a function only once or twice I can use the syntax `function/dataset` through the notation `package::functionname` .

    ```{r}
    DMwR2::algae
    ```

If I want to look into the installed packages in my system, I can use the code `library()` without passing any arguments inside it followed by `(.packages())` .

```{r}
library()
(.packages())
```

So, the above packages are loaded for my current session in my system.

To be more precise, I will consider `library()` to be a super set and the package which i want to check be a subset. Here `(.packages())` lists out all the available packages in the system.

The `datach` function removes a package installed. To demonstrate it, I will first install a package called 'dbplyr' and then I will remove it from my session using `detach` command.

```{r}
install.packages("dbplyr") # I am installing the package

library(dbplyr) 
(.packages()) # I am oading the package to the current session

detach("package:dbplyr", unload=TRUE) 
(.packages()) # I am detaching the package

library(dplyr)# I am loading wanted library
    
```

In the above example, I have successfully detached the wrong package and added the right package.

I can also see the installed packages using the code `installed.packages()` .

```{r}
installed.packages() 
```

To find if the installed packages have a newer version, I will use the code `old.packages()` .

```{r}
old.packages()
```

Similarly I can update my packages using `update.packages()` .

```{r, eval=FALSE}
update.packages()
```

Moreover, I can just type in the name of the function installed through a package by just entering the name. For example, `mean` is a function from base package.

```{r}
mean
```

To find out more information about `mean` I can always use the code `help(mean)`. If there are two functions having the same name but belong to different packages, the code `package::functionname` shall be used to exactly specify the function and it's package.

```{r}
help(mean)
```

Let's say if i want to do a neural networking project in R and I want to find the related packages, I can browse through the web using the code `RSiteSearch('neural networks')`

```{r}
RSiteSearch('neural networks')
```

### Project and session management

In this section, I will use posit cloud to demonstrate the management of project.

On the top menu bar, below `File` option there is a small `new file` option from where I can select the type of project I are going to work with. Some of them are R Script, R markdown, Quarto, etc. I can select the relevant option to me and start working on assignments or projects.

To resume the project, I can click on `File` and select `open file` . Now I have successfully resumed my project. This location is my project working directory, which means all my files will be stored here, especially .R and .Rdata files.

When finishing the project, it is always important to push all the changes to the github repository to prevent loss of data. After pushing the data into github, we can simply close the window.

There are some cool features in posit cloud. I can create a R script and run the entire script at once. and i can also render the code chunk by chunk.

It is a really good practice to save our changes frequently to prevent loss of data and for later use.

### Save changes

To save the current workspace we should enter the following code. Note that, this code always saves the current workspace in .Rdata format.

```{r, eval=FALSE}
save.image()
```

`getwd()` and `setwd()` will help us to get and set the working directory respctively.

```{r, eval=FALSE}
getwd() #this will fetch the working directory

setwd("/enter/your/path/here") #I am setting a new directory here

getwd() #since I have set a new directory, that will show up when running this code

```

### R Objects and Variables

Variables are like names to the memory location of a computer where it holds certain data and the data can be a simple number or a complex one.

```{r}
hello1 <- 0.5 # I have assigned the variable hello1 with the value 0.5

hello1 #when i call this variable this should return 0.5
```

Use () to enclose a statement to have the returned values print directly:

```{r}
(hello1 <- 0.5) #I have enclosed it with round brackets, hence this will print the values directly
```

Some examples:

```{r}
x <- 5
y <- hello1 * x
y
```

```{r}
z <-(y/2)^3
y
```

```{r}
z
```

All the declared variables continue to be alive until I delete it or exit posit cloud without saving. To list out the variables I can use the code `ls()` or `objects()`.

```{r}
ls() #I am listing all the active objects in the current session
```

```{r}
objects() ##I am listing all the active objects in the current session
```

Remove a variable to free memory space:

```{r}
rm(hello1) #I am deleting hello1 variable from the working session

objects() #updated variables
```

### R functions

R functions are something which requires an input to give us an output by performing an operation. R has many functions and libraries that I can use in my program.

Some of the examples:

```{r}
max(1, 5, 7, 12, -9) #this gives the maximum of input arguements
```

```{r}
mean(1, 5, 7, 12, -4) #this finds the mean of the input arguements
```

```{r}
max(sample(1:100, 50)) #this function generates 50 random numbers from 1 to 100 and finds the maximum value out of them
```

```{r}
mean(sample(1:100, 30)) #this function generates 30 random numbers from 1 to 100 and finds their mean
```

```{r}
help("sample") # this helps me to understand what sample does
```

```{r}
set.seed(1) #the seed determines the starting point used in generating a sequence of pseudo random numbers #set.seed() has global scope, meaning it affects all random number generators used/called in your program.

#there is a function to remove the seed:rm(.Random.seed, envir=.GlobalEnv)

rnorm(1) #give me one number from a normal distribution
```

```{r}
set.seed(5) #setting the seed to 5
rnorm(1) #give me one number from a normal distribution
```

`set.seed()` is basically used to produce the same output. Hence it is helpful in debugging of programs.

Now, I will create some custom functions. Before creating any function, it is important to check if the function exists. For that I will use the code `exists()` and pass in the name of the function as arguement. I want to create a function to find standard error of means `se` .

```{r}
exists('se') #checking if func 'se' exists
```

So as seen above, the function doesn't exist. So let's create a new one.

```{r}
se <- function(x){
  variance <- var(x)
  n <-length(x)
  return (sqrt(variance/n))
} #creating the function se
```

I have created the function. Let's verify,

```{r}
exists('se') #checking if func 'se' exists
```

As we can see function 'se' is created successfully. Now let's create another function with multiple arguements.

```{r}
convMeters <- function (x, to="inch"){
  factor = switch(to, inch=39.3701, foot=3.28084, yard=1.09361, mile=0.000621371, NA)
  if(is.na(factor)) stop ("unknown target unit")
  else return (x*factor)
} #this function converts meters to inch, foot, yard and miles

convMeters(50, "foot") #testing the function
```

```{r}
convMeters(40) #If no argument to is provided, the default value 'inch' is used
```

```{r}
convMeters(to="yard", 56.2) #arguements can also be given in other orders if they are named such that R can un-ambiguously assign the arguments for a function
```

### Factors

Factors are like a group of variables but they are limited. So, each factor is a category of unique variables. To create a factor we use the code `factor()`. factors are represented as internal numeric vectors.\
\
Let's create a factor which contains two categorical variables `f` and `m` .

```{r}
g <-c('f', 'm', 'f', 'f', 'f', 'm', 'm', 'f')
g <- factor(g)
```

So, we have successfully created a factor with levels 'f' and 'm' . Another way of creating a factor is shown below:

```{r}
other.g <-factor(c('m', 'm', 'm', 'm'), levels= c('f', 'm'))
other.g
```

Let's now compare the above with the following variable:

```{r}
other.g <-factor(c('m', 'm', 'm', 'm'))
other.g
```

The code correctly categorized the variables as level `m` .

The `table()` function helps us to categorize and summarize the data into a table. Let's see the demonstration below:

```{r}
g <- factor(c('f', 'm', 'f', 'f', 'f', 'm', 'm', 'f'))
table(g) #we have created a table with factor of levels 'f' and 'm'
```

I will add age factor to the table.

```{r}
a <- factor(c('adult', 'juvenile','adult', 'juvenile','adult', 'juvenile','juvenile', 'juvenile'))
table(a, g) #I have successfully added factors 'adult' and 'juvenile'
```

By default, R assumes that both the factors belong to the same entity. Let's consider, in our dataset we have 3 female adult, 2 female juvenile, and 3 male juvenile.

```{r}
a <- factor(c('adult', 'juvenile','adult', 'juvenile','adult', 'juvenile','juvenile'))
table(a, g)
```

It says error because the factor is not of the same length of `g` . Now, I will create a new table of `a` which aligns with the length of `g` .

```{r}
a <- factor(c('adult', 'juvenile','adult', 'juvenile','adult', 'juvenile','juvenile', 'juvenile'))
t <- table(a, g) #i have created a table which aligns with the length of g

t
```

Now let's find the marginal frequencies.

```{r}
margin.table(t, 1)#1 refers to the first factor, a (age)
```

```{r}
margin.table(t, 2)#2 refers to the second factor, g
```

Now I will find the relative frequencies with respect to each margin and the overall:

```{r}
t #I am printing the table 
```

```{r}
prop.table(t, 1) #I am using the margin generated for the 1st factor a 
```

It says that juveniles are 40% female and 60% male and the adults are all males.

```{r}
prop.table(t, 2) #I am using the margin generated for the 1st factor g
```

```{r}
prop.table(t) #overall
```

Now, I will print the same output in percentages:

```{r}
prop.table(t) * 100
```

### R data structures

#### Vectors

Vectors are one of the data objects. A number is a vector with single element. The elements in a vector should be of same data type.

```{r}
v <- c(2, 5, 3, 4) #creating a vector
length(v)
```

```{r}
mode(v) #this finds out the data type in the vector
```

```{r}
v <- c(2, 5, 3, 4, 'me') #now, I will create a vector with strings and numeric variables

mode(v) 
```

```{r}
v
```

Now all the elements of the vector became character strings.

We can use `NA` to represent a special character. For eg.

```{r}
v <- c(2, 5, 3, 4, NA)
mode(v)
```

```{r}
v
```

As we can see above the `NA` did not affect the type of elements.

Now I will create a Boolean vector

```{r}
b <- c(TRUE, FALSE, NA, TRUE)
mode(b) #the output will be 'logical' as this is boolean elements
```

```{r}
b
```

Elements in vectors are indexed from \[1\].

```{r}
b[3] #printing the 3rd element
```

```{r}
b[3] <- TRUE #replacing the third element and printing the vector
b
```

Vectors are elastic, so i can add data to any index

```{r}
b[8] <- FALSE #I have added false to 8th position
b #printing the output
```

All the empty indexes are stored with missing value `NA` .

```{r}
e <-vector() #creating an empty vector
mode(e)
```

```{r}
e <- c()
mode(e)
```

As we can see it says NULL which signifies that the vector is empty

```{r}
length(e)
```

I will use vector elements to construct another vector

```{r}
b2 <-c(b[1], b[3], b[5])
b2
```

```{r}
sqrt(v) #the square root of all elements in v
```

#### Vector Arithmetic

Let's perform some arithmetic operations:

```{r}
v1 <- c(3, 6, 9)
v2 <- c(1, 4, 8)
v1+v2 #addition
```

```{r}
v1*v2 #dot product
```

```{r}
v1-v2 #subtraction
```

```{r}
v1/v2 #divsion
```

Recycling rule says that when performing arithmetic operations between two vectors, and if any one of the vector is of different length, the shorter vector will repeat it's elements starting from the index 1 of the same vector.

```{r}
v3 <- c(1, 4)
v1+v3#the recycling rule makes v3 [1, 4, 1]
```

A single number is also a vector

```{r}
2*v1
```

#### Vector Summary

In this section we have seen that:

1.  The elements in a vector are of same data types.
2.  Vectors are elastic
3.  Arithmetic operations of vectors
4.  Recycling rule

```{r}
mysum <- function (x){
  sum <- 0
  for(i in 1:length(x)){
    sum <- sum + x[i]
  }
  return (sum)
} #for loop

(mysum (c(1, 2, 3)))
```

In the above code the vector iterates inside the mysum and adds them, thus giving a output of 6.

# Part 2

## Easy ways to generate vectors

We can use `()` to print the result of a statement.

```{r}
(x <-1:10) #printing nos from 1 to 10
```

```{r}
(x <-10:1) #printing nos from 10 to 1
```

```{r}
10:15-1 # the precedence of ':' is higher than arithmetic operators.
```

```{r}
10:(15-1) 
```

```{r}
#we can use seq() to generate sequence

(seq(from=1, to=5, length=4)) # 4 values between 1 and 5 inclusive, even intervals/steps
```

```{r}
(seq(length=10, from=-2, by=0.5)) #10 values, starting from 2, interval/step = 0.5
```

```{r}
#rep(x, n): repeat x n times

(rep(5, 10))
```

```{r}
(rep("hi", 3)) #repeats hi 3 times
```

```{r}
(rep(1:2, 3)) #print 1:2 3 times
```

```{r}
(rep(TRUE:FALSE, 3)) #boolean
```

```{r}
(rep(1:3, each=3)) #printing each of the elements 3 times
```

```{r}
#gl() is for generating factor levels

gl(3, 5) #three levels, each repeat 5 times
```

```{r}
gl(2, 5, labels= c('female', 'male'))#two levels, each level repeat 5 times
```

```{r}
#first argument 2 says two levels. 
#second argument 1 says repeat once
#third argment 20 says generate 20 values

gl(2, 1, 20, labels=c('female', 'male'))#10 alternating female and male pairs, a total of 20 values.
```

```{r}
#we can use factor() to convert number sequence to factor level labels

n <- rep(1:2, each=3)
(n <- factor(n, 
             levels = c(1, 2),
             labels = c('female','male')
             ))
```

```{r}
n
```

To generate random data according to some probability density functions: the functions has a general signature of `rfunc(n, par1, par2, …)`, where

1.  `r` for random
2.  `func` is the density function
3.  `n` is the length of the data
4.  `par1`, `par2`, `…` are the parameters

Question: Generate 10 values following a `normal distribution` with `mean = 10` and `standard deviation = 3`

```{r}
#Answer

(rnorm(10, mean=10, sd=3))
```

```{r}
#another example 

(rt(10, df=5)) #generates a random sample of 10 values from a Student's t-distribution with 5 degrees of freedom
```

Exercise :

1.  Generate a random sample of `normally distributed` data of `size 100`, with a `mean of 20` and `standard deviation 4.`
2.  Compute the standard error of means of the dataset.

```{r}
#solution for 1
sample <- rnorm(100, mean=20, sd=4)
sample
```

```{r}
# solution for 2

# creating a function to calculate standard error of means
se <- function(x){
  variance <- var(x)
  n <-length(x)
  return (sqrt(variance/n))
} 

#passing the arguement 'sample' to compute the result
se(sample)
```

## Sub-setting

There are additional ways by which I can select the values from the vector.

```{r}
#example

x <- c(0, -3, 4, -1, 45, 90, -5) #creating a vector

#select all elements that is greater than 0
(gtzero <- x[x>0])
```

We can use Boolean operators to select values.

```{r}
#use of | (or), and & (and) operators

x <- c(0, -3, 4, -1, 45, 90, -5) #creating a vector

(x[x<=-2 | x>5]) #using 'or' operator
```

```{r}
(x[x>40 & x<100]) #using 'and' operator
```

We can use vector index to select values

```{r}
x <- c(0, -3, 4, -1, 45, 90, -5) #creating a vector

(x[c(4, 6)])#select the 4th and 6th elements in the vector
```

```{r}
(y<-c(4,6)) #similar example

(x[y]) #passing of vectors as index value arguements
```

```{r}
(x[1:3]) #select the 1st to the 3rd elements in the vector
```

We can use negative index to exclude elements

```{r}
x <- c(0, -3, 4, -1, 45, 90, -5)

(x[-1]) #select all but the first element
```

```{r}
(x[-c(4, 6)]) #excluding 4th and 6th element
```

```{r}
(x[-(1:3)]) #excluding first 3 elements
```

### Named elements

We can assign names to each value in a vector.

```{r}
x <- c(0, -3, 4, -1, 45, 90, -5) #creating a vector

names(x) <- c('s1', 's2', 's3', 's4', 's5', 's6', 's7') #assigning names

x
```

```{r}
#another way of naming elements

(pH <- c(area1=4.5, area2=5.7, area3=9.8, mud=7.2))
```

```{r}
# we can use individual names to select the element

(pH['mud'])

(pH[c('area1', 'mud')])
```

We cannot exclude elements with it's names.

```{r}
(x[-s1]) #results in error
```

```{r}
(x[-"s1"]) #results in error
```

```{r}
(x[s1:s7]) #results in error
```

```{r}
(x[c('s1':'s7')]) #results in error
```

```{r}
#Empty index means to select all

(pH[])

pH
```

To reset a vector to '0' we use,

```{r}
pH[] <- 0
pH #assigning 0 to pH
```

```{r}
pH<- 0
pH #same as above
```

## More R-Data structures

### **Matrices and Arrays**

Arrays and Matrices are long vectors categorized by dimensions. Moreover, Arrays can be of multiple dimension, whereas Matrices are two dimensional. They both hold the same type of value.

#### Matrices

```{r}
#To create a matrix:

m <- c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23) #creating a vector

is.vector(m) #checking if this is a vector
```

```{r}
is.matrix(m) #checking if this is a matrix
```

```{r}
is.array(m) #checking if this is an array
```

```{r}
#now 'organize' the vector as a matrix

dim(m) <-c(2, 5)#make the vector a 2 by 5 matrix, 2x5 must = lenght of the vector

m
```

```{r}
#re-checking

(is.vector(m))

(is.matrix(m))

(is.array(m))
```

The elements are put in matrix in columns by default. If we want to use in rows, we should use the code `byrow=TRUE`.

```{r}
#example

(m <- matrix(c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23), 2, 5, byrow = TRUE))
```

#### Exercise:

First columns hold age data for a group of students `11, 11, 12, 13, 14, 9, 8`, and second columns hold grades `5, 5, 6, 7, 8, 4, 3`.

```{r}
#solution

studentsAndGrades <-matrix(c(11, 11, 12, 13, 14, 9, 8, 5, 5, 6, 7, 8, 4, 3), 7, 2) #creating a matrix with exercise data and 7*2 dimension

studentsAndGrades
```

Same as vectors, we can access matrix by their position index.

```{r}
#creating a matrix

m <- c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23)
#then 'organize' the vector as a matrix

dim(m) <- c(2, 5)#make the vector a 2 by 5 matrix, 2x5 must = lenght of the vector

m
```

```{r}
m[2, 3]#the element at row 2 and column 3
```

Similarly, we can use sub-setting for matrix also. The result will be a value (a value is a vector), a vector, or a matrix.

```{r}
(s<- m[2, 1]) # select one value
```

```{r}
(m<- m [c(1,2), -c(3, 5)]) #select 1st row and 1st, 2nd, and 4th columns, result is a vector
```

```{r}
(m [1, ]) #select complete row or column: 1st row, result is a vector
```

```{r}
(v<-m [, 1]) # 1st column, result is a vector
```

```{r}
#performing checks to verify

is.vector(m)
```

```{r}
is.matrix(m)
```

```{r}
is.vector(s)
```

```{r}
is.vector(v)
```

```{r}
is.matrix(v)
```

```{r}
#Use drop = FALSE to keep the results as a matrix

m <- matrix(c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23), 2, 5)
(m<-m [, 2, drop = FALSE])
```

```{r}
is.matrix(m)
```

```{r}
is.vector(m)
```

If we want to join together two or more vectors or matrices, by column, or by row, respectively, we can use the code `cbind()` and `rbind().`

```{r}
#example

cbind (c(1,2,3), c(4, 5, 6)) #joining columns
```

```{r}
rbind (c(1,2,3), c(4, 5, 6)) #joining rows
```

```{r}
m <- matrix(c(45, 23, 66, 77, 33, 44, 56, 12, 78, 23), 2, 5)

(a <- rbind (c(1,2,3,4,5), m)) #joining a to m as rows
```

```{r}
is.array(a)
```

```{r}
is.matrix(a)
```

#### Exercise:

What will `m1-m4` look like?

```{r}
#solution
m1 <- matrix(rep(10, 9), 3, 3) 
m1
```

```{r}
m2 <- cbind (c(1,2,3), c(4, 5, 6)) 
m2
```

```{r}
m3 <- cbind (m1[,1], m2[2,]) 
m3
```

```{r}
m4 <- cbind (m1[,1], m2[,2])
m4
```

Since m3 number of rows of result is not a multiple of vector length m2, it is not possible to bind them.

#### Named rows and columns

```{r}
#we can name elements in matrix

sales <- matrix(c(10, 30, 40, 50, 43, 56, 21, 30), 2, 4, byrow=TRUE)
colnames(sales) <- c('1qrt', '2qrt', '3qrt', '4qrt')
rownames(sales) <- c('store1', 'store2')
sales
```

#### Exercise:

Find `store1` `1qrt` sale. 2. List `store2`\'s 1st and 4th quarter sales

```{r}
#solution

sales['store1', '1qrt']
```

```{r}
sales['store2', c('1qrt', '4qrt')]
```

### Lists

### **Subset with `[`**

### **Extract one item with `[[`**

### **Interact with `$`**

### **Remove list components using negative index, or using NULL**

## Data frames

## Tibbles

## dplyr
